{"ast":null,"code":"import PropTypes from 'prop-types';\nimport React, { Component } from 'react';\nimport ReactDOM from 'react-dom';\n\nObject.assign = Object.assign || function (target) {\n  var arguments$1 = arguments;\n\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments$1[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction mask(value, precision, decimalSeparator, thousandSeparator, allowNegative, prefix, suffix) {\n  if (precision === void 0) precision = 2;\n  if (decimalSeparator === void 0) decimalSeparator = '.';\n  if (thousandSeparator === void 0) thousandSeparator = ',';\n  if (allowNegative === void 0) allowNegative = false;\n  if (prefix === void 0) prefix = '';\n  if (suffix === void 0) suffix = ''; // provide some default values and arg validation.\n\n  if (precision < 0) {\n    precision = 0;\n  } // precision cannot be negative\n\n\n  if (precision > 20) {\n    precision = 20;\n  } // precision cannot be greater than 20\n\n\n  if (value === null || value === undefined) {\n    return {\n      value: 0,\n      maskedValue: ''\n    };\n  }\n\n  value = String(value); //if the given value is a Number, let's convert into String to manipulate that\n\n  if (value.length == 0) {\n    return {\n      value: 0,\n      maskedValue: ''\n    };\n  } // extract digits. if no digits, fill in a zero.\n\n\n  var digits = value.match(/\\d/g) || ['0'];\n  var numberIsNegative = false;\n\n  if (allowNegative) {\n    var negativeSignCount = (value.match(/-/g) || []).length; // number will be negative if we have an odd number of \"-\"\n    // ideally, we should only ever have 0, 1 or 2 (positive number, making a number negative\n    // and making a negative number positive, respectively)\n\n    numberIsNegative = negativeSignCount % 2 === 1; // if every digit in the array is '0', then the number should never be negative\n\n    var allDigitsAreZero = true;\n\n    for (var idx = 0; idx < digits.length; idx += 1) {\n      if (digits[idx] !== '0') {\n        allDigitsAreZero = false;\n        break;\n      }\n    }\n\n    if (allDigitsAreZero) {\n      numberIsNegative = false;\n    }\n  } // zero-pad a input\n\n\n  while (digits.length <= precision) {\n    digits.unshift('0');\n  }\n\n  if (precision > 0) {\n    // add the decimal separator\n    digits.splice(digits.length - precision, 0, \".\");\n  } // clean up extraneous digits like leading zeros.\n\n\n  digits = Number(digits.join('')).toFixed(precision).split('');\n  var raw = Number(digits.join(''));\n  var decimalpos = digits.length - precision - 1; // -1 needed to position the decimal separator before the digits.\n\n  if (precision > 0) {\n    // set the final decimal separator\n    digits[decimalpos] = decimalSeparator;\n  } else {\n    // when precision is 0, there is no decimal separator.\n    decimalpos = digits.length;\n  } // add in any thousand separators\n\n\n  for (var x = decimalpos - 3; x > 0; x = x - 3) {\n    digits.splice(x, 0, thousandSeparator);\n  } // if we have a prefix or suffix, add them in.\n\n\n  if (prefix.length > 0) {\n    digits.unshift(prefix);\n  }\n\n  if (suffix.length > 0) {\n    digits.push(suffix);\n  } // if the number is negative, insert a \"-\" to\n  // the front of the array and negate the raw value\n\n\n  if (allowNegative && numberIsNegative) {\n    digits.unshift('-');\n    raw = -raw;\n  }\n\n  return {\n    value: raw,\n    maskedValue: digits.join('').trim()\n  };\n} // IE* parseFloat polyfill\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat#Polyfill\n\n\nNumber.parseFloat = parseFloat;\n\nvar CurrencyInput = function (Component$$1) {\n  function CurrencyInput(props) {\n    Component$$1.call(this, props);\n    this.prepareProps = this.prepareProps.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n    this.handleFocus = this.handleFocus.bind(this);\n    this.state = this.prepareProps(this.props);\n    this.inputSelectionStart = 1;\n    this.inputSelectionEnd = 1;\n  }\n\n  if (Component$$1) CurrencyInput.__proto__ = Component$$1;\n  CurrencyInput.prototype = Object.create(Component$$1 && Component$$1.prototype);\n  CurrencyInput.prototype.constructor = CurrencyInput;\n  /**\n   * Exposes the current masked value.\n   *\n   * @returns {String}\n   */\n\n  CurrencyInput.prototype.getMaskedValue = function getMaskedValue() {\n    return this.state.maskedValue;\n  };\n  /**\n   * General function used to cleanup and define the final props used for rendering\n   * @returns {{ maskedValue: {String}, value: {Number}, customProps: {Object} }}\n   */\n\n\n  CurrencyInput.prototype.prepareProps = function prepareProps(props) {\n    var customProps = Object.assign({}, props); // babeljs converts to Object.assign, then polyfills.\n\n    delete customProps.onChange;\n    delete customProps.onChangeEvent;\n    delete customProps.value;\n    delete customProps.decimalSeparator;\n    delete customProps.thousandSeparator;\n    delete customProps.precision;\n    delete customProps.inputType;\n    delete customProps.allowNegative;\n    delete customProps.allowEmpty;\n    delete customProps.prefix;\n    delete customProps.suffix;\n    delete customProps.selectAllOnFocus;\n    delete customProps.autoFocus;\n    var initialValue = props.value;\n\n    if (initialValue === null) {\n      initialValue = props.allowEmpty ? null : '';\n    } else {\n      if (typeof initialValue == 'string') {\n        // Some people, when confronted with a problem, think \"I know, I'll use regular expressions.\"\n        // Now they have two problems.\n        // Strip out thousand separators, prefix, and suffix, etc.\n        if (props.thousandSeparator === \".\") {\n          // special handle the . thousand separator\n          initialValue = initialValue.replace(/\\./g, '');\n        }\n\n        if (props.decimalSeparator != \".\") {\n          // fix the decimal separator\n          initialValue = initialValue.replace(new RegExp(props.decimalSeparator, 'g'), '.');\n        } //Strip out anything that is not a digit, -, or decimal separator\n\n\n        initialValue = initialValue.replace(/[^0-9-.]/g, ''); // now we can parse.\n\n        initialValue = Number.parseFloat(initialValue);\n      }\n\n      initialValue = Number(initialValue).toLocaleString(undefined, {\n        style: 'decimal',\n        minimumFractionDigits: props.precision,\n        maximumFractionDigits: props.precision\n      });\n    }\n\n    var ref = mask(initialValue, props.precision, props.decimalSeparator, props.thousandSeparator, props.allowNegative, props.prefix, props.suffix);\n    var maskedValue = ref.maskedValue;\n    var value = ref.value;\n    return {\n      maskedValue: maskedValue,\n      value: value,\n      customProps: customProps\n    };\n  };\n  /**\n   * Component lifecycle function.\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\n   *\n   * @param nextProps\n   * @see https://facebook.github.io/react/docs/component-specs.html#updating-componentwillreceiveprops\n   */\n\n\n  CurrencyInput.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    this.setState(this.prepareProps(nextProps));\n  };\n  /**\n   * Component lifecycle function.\n   * @returns {XML}\n   * @see https://facebook.github.io/react/docs/react-component.html#componentdidmount\n   */\n\n\n  CurrencyInput.prototype.componentDidMount = function componentDidMount() {\n    var node = ReactDOM.findDOMNode(this.theInput);\n    var selectionStart, selectionEnd;\n\n    if (this.props.autoFocus) {\n      this.theInput.focus();\n      selectionEnd = this.state.maskedValue.length - this.props.suffix.length;\n      selectionStart = selectionEnd;\n    } else {\n      selectionEnd = Math.min(node.selectionEnd, this.theInput.value.length - this.props.suffix.length);\n      selectionStart = Math.min(node.selectionStart, selectionEnd);\n    }\n\n    node.setSelectionRange(selectionStart, selectionEnd);\n  };\n  /**\n   * Component lifecycle function\n   * @returns {XML}\n   * @see https://facebook.github.io/react/docs/react-component.html#componentwillupdate\n   */\n\n\n  CurrencyInput.prototype.componentWillUpdate = function componentWillUpdate() {\n    var node = ReactDOM.findDOMNode(this.theInput);\n    this.inputSelectionStart = node.selectionStart;\n    this.inputSelectionEnd = node.selectionEnd;\n  };\n  /**\n   * Component lifecycle function.\n   * @returns {XML}\n   * @see https://facebook.github.io/react/docs/react-component.html#componentdidupdate\n   */\n\n\n  CurrencyInput.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var ref = this.props;\n    var decimalSeparator = ref.decimalSeparator;\n    var node = ReactDOM.findDOMNode(this.theInput);\n    var isNegative = (this.theInput.value.match(/-/g) || []).length % 2 === 1;\n    var minPos = this.props.prefix.length + (isNegative ? 1 : 0);\n    var selectionEnd = Math.max(minPos, Math.min(this.inputSelectionEnd, this.theInput.value.length - this.props.suffix.length));\n    var selectionStart = Math.max(minPos, Math.min(this.inputSelectionEnd, selectionEnd));\n    var regexEscapeRegex = /[-[\\]{}()*+?.,\\\\^$|#\\s]/g;\n    var separatorsRegex = new RegExp(decimalSeparator.replace(regexEscapeRegex, '\\\\$&') + '|' + this.props.thousandSeparator.replace(regexEscapeRegex, '\\\\$&'), 'g');\n    var currSeparatorCount = (this.state.maskedValue.match(separatorsRegex) || []).length;\n    var prevSeparatorCount = (prevState.maskedValue.match(separatorsRegex) || []).length;\n    var adjustment = Math.max(currSeparatorCount - prevSeparatorCount, 0);\n    selectionEnd = selectionEnd + adjustment;\n    selectionStart = selectionStart + adjustment;\n    var precision = Number(this.props.precision);\n    var baselength = this.props.suffix.length + this.props.prefix.length + (precision > 0 ? decimalSeparator.length : 0) // if precision is 0 there will be no decimal part\n    + precision + 1; // This is to account for the default '0' value that comes before the decimal separator\n\n    if (this.state.maskedValue.length == baselength) {\n      // if we are already at base length, position the cursor at the end.\n      selectionEnd = this.theInput.value.length - this.props.suffix.length;\n      selectionStart = selectionEnd;\n    }\n\n    node.setSelectionRange(selectionStart, selectionEnd);\n    this.inputSelectionStart = selectionStart;\n    this.inputSelectionEnd = selectionEnd;\n  };\n  /**\n   * onChange Event Handler\n   * @param event\n   */\n\n\n  CurrencyInput.prototype.handleChange = function handleChange(event) {\n    var this$1 = this;\n    event.preventDefault();\n    var ref = mask(event.target.value, this.props.precision, this.props.decimalSeparator, this.props.thousandSeparator, this.props.allowNegative, this.props.prefix, this.props.suffix);\n    var maskedValue = ref.maskedValue;\n    var value = ref.value;\n    event.persist(); // fixes issue #23\n\n    this.setState({\n      maskedValue: maskedValue,\n      value: value\n    }, function () {\n      this$1.props.onChange(maskedValue, value, event);\n      this$1.props.onChangeEvent(event, maskedValue, value);\n    });\n  };\n  /**\n   * onFocus Event Handler\n   * @param event\n   */\n\n\n  CurrencyInput.prototype.handleFocus = function handleFocus(event) {\n    if (!this.theInput) {\n      return;\n    } //Whenever we receive focus check to see if the position is before the suffix, if not, move it.\n\n\n    var selectionEnd = this.theInput.value.length - this.props.suffix.length;\n    var isNegative = (this.theInput.value.match(/-/g) || []).length % 2 === 1;\n    var selectionStart = this.props.prefix.length + (isNegative ? 1 : 0);\n    this.props.selectAllOnFocus && event.target.setSelectionRange(selectionStart, selectionEnd);\n    this.inputSelectionStart = selectionStart;\n    this.inputSelectionEnd = selectionEnd;\n  };\n\n  CurrencyInput.prototype.handleBlur = function handleBlur(event) {\n    this.inputSelectionStart = 0;\n    this.inputSelectionEnd = 0;\n  };\n  /**\n   * Component lifecycle function.\n   * @returns {XML}\n   * @see https://facebook.github.io/react/docs/component-specs.html#render\n   */\n\n\n  CurrencyInput.prototype.render = function render() {\n    var this$1 = this;\n    return React.createElement('input', Object.assign({}, {\n      ref: function (input) {\n        this$1.theInput = input;\n      },\n      type: this.props.inputType,\n      value: this.state.maskedValue,\n      onChange: this.handleChange,\n      onFocus: this.handleFocus,\n      onMouseUp: this.handleFocus\n    }, this.state.customProps));\n  };\n\n  return CurrencyInput;\n}(Component);\n/**\n * Prop validation.\n * @see https://facebook.github.io/react/docs/component-specs.html#proptypes\n */\n\n\nCurrencyInput.propTypes = {\n  onChange: PropTypes.func,\n  value: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  decimalSeparator: PropTypes.string,\n  thousandSeparator: PropTypes.string,\n  precision: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n  inputType: PropTypes.string,\n  allowNegative: PropTypes.bool,\n  allowEmpty: PropTypes.bool,\n  prefix: PropTypes.string,\n  suffix: PropTypes.string,\n  selectAllOnFocus: PropTypes.bool\n};\nCurrencyInput.defaultProps = {\n  onChange: function (maskValue, value, event) {\n    /*no-op*/\n  },\n  onChangeEvent: function (event, maskValue, value) {\n    /*no-op*/\n  },\n  autoFocus: false,\n  value: '0',\n  decimalSeparator: '.',\n  thousandSeparator: ',',\n  precision: '2',\n  inputType: 'text',\n  allowNegative: false,\n  prefix: '',\n  suffix: '',\n  selectAllOnFocus: false\n};\nexport default CurrencyInput;","map":null,"metadata":{},"sourceType":"module"}